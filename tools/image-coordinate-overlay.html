<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Coordinate Overlay - RƒÉzvan-Mihai Ursu</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="image-coordinate-overlay-styles.css">
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">‚Üê Back to Portfolio</a>
        
        <header>
            <h1>üìç Image Coordinate Overlay</h1>
            <p class="subtitle">Add GPS coordinates to your images - entirely in your browser</p>
            <p>Made with ‚ù§Ô∏è by <a href="https://github.com/razvanursu" target="_blank">Razvan Ursu</a> and AI ü§ñ</p>
        </header>

        <div class="tab-container">
            <div class="tab-content">
                <div class="content-section active">
                    <!-- Upload Section -->
                    <div class="card upload-section" id="uploadSection">
                        <h3>üìÅ Select or Drop Your Image</h3>
                        <p>Supports JPEG, PNG, HEIC/HEIF, and other formats (HEIC images will be automatically converted)</p>
                        <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                            Choose Image File
                        </button>
                        <input type="file" id="fileInput" accept="image/*,.heic,.heif" multiple>
                        <div class="progress-bar" id="progressBar" style="display: none;">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>

                    <!-- Configuration Section -->
                    <div class="card">
                        <h3>‚öôÔ∏è Overlay Configuration</h3>
                        <div class="config-grid">
                            <div class="config-group">
                                <h4>Font Sizes</h4>
                                <div class="form-row">
                                    <label>Coordinate Text:</label>
                                    <input type="number" id="coordinateFontSize" value="144" min="20" max="300">
                                </div>
                                <div class="form-row">
                                    <label>Source Text:</label>
                                    <input type="number" id="sourceFontSize" value="72" min="16" max="150">
                                </div>
                            </div>

                            <div class="config-group">
                                <h4>Colors</h4>
                                <div class="form-row">
                                    <label>Coordinate Color:</label>
                                    <input type="color" id="coordinateColor" value="#ffffff">
                                </div>
                                <div class="form-row">
                                    <label>Source Color:</label>
                                    <input type="color" id="sourceColor" value="#d3d3d3">
                                </div>
                                <div class="form-row">
                                    <label>Background Color:</label>
                                    <input type="color" id="backgroundColor" value="#000000">
                                </div>
                            </div>

                            <div class="config-group">
                                <h4>Position & Layout</h4>
                                <div class="form-row">
                                    <label>Vertical Position:</label>
                                    <select id="verticalPosition">
                                        <option value="bottom">Bottom</option>
                                        <option value="top">Top</option>
                                        <option value="center">Center</option>
                                    </select>
                                </div>
                                <div class="form-row">
                                    <label>Alignment:</label>
                                    <select id="alignment">
                                        <option value="center">Center</option>
                                        <option value="left">Left</option>
                                        <option value="right">Right</option>
                                    </select>
                                </div>
                                <div class="form-row">
                                    <label>Full Width:</label>
                                    <input type="checkbox" id="fullWidth" checked>
                                </div>
                            </div>

                            <div class="config-group">
                                <h4>Format & Padding</h4>
                                <div class="form-row">
                                    <label>Decimal Places:</label>
                                    <input type="number" id="decimalPlaces" value="9" min="1" max="10">
                                </div>
                                <div class="form-row">
                                    <label>Vertical Padding:</label>
                                    <input type="number" id="verticalPadding" value="100" min="10" max="300">
                                </div>
                                <div class="form-row">
                                    <label>Include Emoji:</label>
                                    <input type="checkbox" id="includeEmoji">
                                </div>
                            </div>

                            <div class="config-group">
                                <h4>Extra Information</h4>
                                <div class="form-row">
                                    <label>Additional Text (optional):</label>
                                    <textarea id="extraInfo" rows="5" maxlength="200" placeholder="Add any additional information to display on your image...&#10;Examples: Location details, event name, photographer credit, etc."></textarea>
                                    <div class="char-counter" id="charCounter">0 / 200 characters</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Custom Coordinates Section -->
                    <div class="card coordinates-section">
                        <h3>üìç Custom Coordinates (Optional)</h3>
                        <p>Leave empty to use GPS data from image metadata</p>
                        <div class="coord-input">
                            <div>
                                <label for="customLat">Latitude:</label>
                                <input type="number" id="customLat" step="any" placeholder="e.g., 40.7128">
                            </div>
                            <div>
                                <label for="customLon">Longitude:</label>
                                <input type="number" id="customLon" step="any" placeholder="e.g., -74.0060">
                            </div>
                        </div>
                    </div>

                    <!-- Browser Location Section -->
                    <div class="card coordinates-section">
                        <h3>üåç Use Current Browser Location</h3>
                        <p>Get your current location using your browser's geolocation service</p>
                        <div class="browser-location">
                            <button class="location-btn" id="getLocationBtn">
                                üìç Get My Current Location
                            </button>
                            <div id="locationStatus" class="location-status"></div>
                            <div id="locationDisplay" class="location-display" style="display: none;">
                                <div class="location-info">
                                    <span id="browserLat">Latitude: --</span>
                                    <span id="browserLon">Longitude: --</span>
                                </div>
                                <button class="use-location-btn" id="useLocationBtn">
                                    ‚úÖ Use This Location
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Info Panel -->
                    <div id="infoPanel" style="display: none;"></div>

                    <!-- Preview Section -->
                    <div class="preview-section">
                        <canvas id="previewCanvas" style="display: none;"></canvas>
                        <div style="margin-top: 20px;">
                            <button class="download-btn" id="downloadBtn" style="display: none;" disabled>
                                üíæ Download Image with Overlay
                            </button>
                            <button class="download-btn" id="processAllBtn" style="display: none;">
                                üîÑ Process All Images
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ExifReader Library - Better HEIC support -->
    <script src="https://cdn.jsdelivr.net/npm/exifreader@4.31.0/dist/exif-reader.js"></script>
    <!-- HEIC-TO Library - Convert HEIC to web-compatible formats (more modern than heic2any) -->
    <script src="https://cdn.jsdelivr.net/npm/heic-to@1.1.13/dist/iife/heic-to.js"></script>
    
    <script>
        class ImageCoordinateOverlay {
            constructor() {
                this.selectedFiles = [];
                this.currentImageData = null;
                this.processedImageFile = null; // Store the converted/processed image file
                this.originalGPSCoords = null; // Store the original GPS coordinates
                this.hasProcessedImage = false; // Track if user has processed an image
                this.setupEventListeners();
                this.loadDefaultConfig();
                this.initializePage();
            }

            initializePage() {
                // Ensure page starts at the top on load
                window.scrollTo(0, 0);
                
                // Prevent any automatic scrolling on page load
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            }

            setupEventListeners() {
                const fileInput = document.getElementById('fileInput');
                const uploadSection = document.getElementById('uploadSection');
                
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag and drop
                uploadSection.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadSection.classList.add('dragover');
                });
                
                uploadSection.addEventListener('dragleave', () => {
                    uploadSection.classList.remove('dragover');
                });
                
                uploadSection.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadSection.classList.remove('dragover');
                    this.handleFileSelect(e);
                });

                // Config changes
                const configInputs = document.querySelectorAll('.config-group input, .config-group select');
                configInputs.forEach(input => {
                    input.addEventListener('change', () => this.updatePreview());
                });

                // Custom coordinates
                document.getElementById('customLat').addEventListener('input', () => this.updatePreview());
                document.getElementById('customLon').addEventListener('input', () => this.updatePreview());

                // Extra information textarea
                document.getElementById('extraInfo').addEventListener('input', () => this.updatePreview());

                // Character counter for extra info textarea
                const extraInfoTextarea = document.getElementById('extraInfo');
                const charCounter = document.getElementById('charCounter');
                
                extraInfoTextarea.addEventListener('input', () => {
                    const currentLength = extraInfoTextarea.value.length;
                    const maxLength = 200;
                    charCounter.textContent = `${currentLength} / ${maxLength} characters`;
                    
                    // Update counter styling based on character count
                    charCounter.className = 'char-counter';
                    if (currentLength > maxLength * 0.8) {
                        charCounter.classList.add('warning');
                    }
                    if (currentLength > maxLength * 0.95) {
                        charCounter.classList.remove('warning');
                        charCounter.classList.add('danger');
                    }
                });

                // Browser geolocation
                document.getElementById('getLocationBtn').addEventListener('click', () => this.getCurrentLocation());
                document.getElementById('useLocationBtn').addEventListener('click', () => this.useBrowserLocation());

                // Download button
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadImage());
                document.getElementById('processAllBtn').addEventListener('click', () => this.processAllImages());
            }

            loadDefaultConfig() {
                // Config is already set in HTML, but we can override here if needed
                this.showInfo('Ready to process images. Upload an image to begin.', 'info');
            }

            handleFileSelect(event) {
                const files = event.target?.files || event.dataTransfer?.files;
                if (!files || files.length === 0) return;

                this.selectedFiles = Array.from(files);
                this.showInfo(`Selected ${files.length} file(s). Processing first image...`, 'info');
                
                if (files.length > 1) {
                    document.getElementById('processAllBtn').style.display = 'inline-block';
                }

                this.processImage(files[0]);
            }

            async processImage(file) {
                try {
                    this.showProgress(10);
                    
                    // Load image (this handles HEIC conversion if needed)
                    const { img, processedFile } = await this.loadImage(file);
                    this.showProgress(30);
                    
                    // Extract GPS coordinates from the original file (for metadata)
                    const coords = await this.extractGPSCoordinates(file);
                    this.showProgress(50);
                    
                    // Store the processed file and coordinates for updatePreview
                    this.processedImageFile = processedFile;
                    this.originalGPSCoords = coords;
                    
                    // Create overlay
                    await this.createOverlay(img, coords, file.name);
                    this.showProgress(100);
                    
                    // Mark that user has processed an image
                    this.hasProcessedImage = true;
                    
                    this.hideProgress();
                    
                } catch (error) {
                    this.showInfo(`Error processing image: ${error.message}`, 'error');
                    console.error('Processing error:', error);
                    this.hideProgress();
                }
            }

            loadImage(file) {
                return new Promise(async (resolve, reject) => {
                    try {
                        let imageFile = file;
                        
                        // Check if the file is HEIC/HEIF format
                        const isHeicFile = file.type === 'image/heic' || file.type === 'image/heif' || 
                                          file.name.toLowerCase().endsWith('.heic') || 
                                          file.name.toLowerCase().endsWith('.heif');
                        
                        if (isHeicFile && typeof HeicTo !== 'undefined') {
                            this.showInfo('üîÑ Converting HEIC image to JPEG (this may take a moment)...', 'info');
                            console.log('Converting HEIC file:', file.name);
                            
                            try {
                                // First check if it's actually a HEIC file
                                const isActuallyHeic = await HeicTo.isHeic(file);
                                
                                if (isActuallyHeic) {
                                    // Convert HEIC to JPEG blob
                                    const convertedBlob = await HeicTo({
                                        blob: file,
                                        type: "image/jpeg",
                                        quality: 0.9
                                    });
                                    
                                    // Create a new File object from the converted blob
                                    imageFile = new File([convertedBlob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), {
                                        type: 'image/jpeg'
                                    });
                                    
                                    console.log('HEIC conversion successful');
                                    this.showInfo('‚úÖ HEIC image converted successfully!', 'success');
                                } else {
                                    // File has HEIC extension but isn't actually HEIC format
                                    console.log('File has HEIC extension but is not HEIC format, using as-is');
                                    this.showInfo('‚ÑπÔ∏è File appears to be already in a compatible format', 'info');
                                }
                            } catch (heicError) {
                                console.error('HEIC conversion failed:', heicError);
                                this.showInfo(`‚ùå Failed to convert HEIC image: ${heicError.message}. Trying to load as regular image...`, 'error');
                                // Don't reject, try to load as regular image
                            }
                        } else if (isHeicFile) {
                            // HEIC file detected but library not available
                            this.showInfo('‚ö†Ô∏è HEIC file detected, but conversion library not loaded. Please try refreshing the page.', 'error');
                        }
                        
                        // Load the image (either original or converted)
                        const img = new Image();
                        const url = URL.createObjectURL(imageFile);
                        
                        img.onload = () => {
                            URL.revokeObjectURL(url);
                            // Return both the image and the processed file
                            resolve({ img, processedFile: imageFile });
                        };
                        
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error('Failed to load image'));
                        };
                        
                        img.src = url;
                        
                    } catch (error) {
                        console.error('Image loading error:', error);
                        reject(error);
                    }
                });
            }

            async extractGPSCoordinates(file) {
                try {
                    // Use ExifReader which has much better HEIC support
                    const tags = await ExifReader.load(file, {
                        expanded: true,  // This groups GPS tags separately
                        gps: true,       // Enable GPS parsing
                        exif: true,      // Enable EXIF parsing
                        tiff: true       // Enable TIFF parsing
                    });
                    
                    console.log('ExifReader tags:', tags); // Debug logging
                    
                    // Check for GPS data in different possible locations
                    let gpsData = null;
                    let latitude, longitude;

                    console.log('GPS raw data:', tags.gps);
                    
                    // Method 1: Check for processed GPS coordinates in gps object (most common)
                    if (tags.gps && typeof tags.gps.Latitude === 'number' && typeof tags.gps.Longitude === 'number') {
                        latitude = tags.gps.Latitude;
                        longitude = tags.gps.Longitude;
                        gpsData = { latitude, longitude, source: 'EXIF GPS (ExifReader)' };
                        console.log('Using processed GPS coordinates:', latitude, longitude);
                    }
                    // Method 2: Check for GPS data in the GPS block with manual conversion
                    else if (tags.gps && tags.gps.GPSLatitude && tags.gps.GPSLongitude && 
                             tags.gps.GPSLatitudeRef && tags.gps.GPSLongitudeRef) {
                        const gpsLat = tags.gps.GPSLatitude;
                        const gpsLon = tags.gps.GPSLongitude;
                        const gpsLatRef = tags.gps.GPSLatitudeRef;
                        const gpsLonRef = tags.gps.GPSLongitudeRef;
                        
                        console.log('GPS raw data:', { gpsLat, gpsLon, gpsLatRef, gpsLonRef });
                        
                        latitude = this.convertDMSToDD(gpsLat.value || gpsLat.description || gpsLat, 
                                                       gpsLatRef.value || gpsLatRef.description || gpsLatRef);
                        longitude = this.convertDMSToDD(gpsLon.value || gpsLon.description || gpsLon, 
                                                        gpsLonRef.value || gpsLonRef.description || gpsLonRef);
                        
                        gpsData = { latitude, longitude, source: 'EXIF GPS (Manual)' };
                        console.log('Manually converted GPS coordinates:', latitude, longitude);
                    }
                    // Method 3: Check for GPS data in main tags object (when expanded: false)
                    else if (tags.GPSLatitude && tags.GPSLongitude && tags.GPSLatitudeRef && tags.GPSLongitudeRef) {
                        const gpsLat = tags.GPSLatitude;
                        const gpsLon = tags.GPSLongitude;
                        const gpsLatRef = tags.GPSLatitudeRef;
                        const gpsLonRef = tags.GPSLongitudeRef;
                        
                        console.log('GPS raw data (main):', { gpsLat, gpsLon, gpsLatRef, gpsLonRef });
                        
                        latitude = this.convertDMSToDD(gpsLat.value || gpsLat.description || gpsLat, 
                                                       gpsLatRef.value || gpsLatRef.description || gpsLatRef);
                        longitude = this.convertDMSToDD(gpsLon.value || gpsLon.description || gpsLon, 
                                                        gpsLonRef.value || gpsLonRef.description || gpsLonRef);
                        
                        gpsData = { latitude, longitude, source: 'EXIF GPS (Main)' };
                        console.log('Manually converted GPS coordinates (main):', latitude, longitude);
                    }
                    
                    // Validate the coordinates
                    if (gpsData && !isNaN(gpsData.latitude) && !isNaN(gpsData.longitude)) {
                        console.log('Valid GPS coordinates found:', gpsData);
                        return gpsData;
                    } else {
                        console.log('No valid GPS coordinates found or coordinates are NaN');
                        return null;
                    }
                } catch (error) {
                    console.error('GPS extraction error:', error);
                    return null;
                }
            }

            convertDMSToDD(dms, ref) {
                console.log('Converting DMS to DD:', { dms, ref });
                
                // Handle different input formats
                let degrees, minutes, seconds;
                
                if (Array.isArray(dms)) {
                    // Standard DMS array format
                    degrees = dms[0] || 0;
                    minutes = dms[1] || 0;
                    seconds = dms[2] || 0;
                } else if (typeof dms === 'object' && dms.value) {
                    // Object with value property
                    if (Array.isArray(dms.value)) {
                        degrees = dms.value[0] || 0;
                        minutes = dms.value[1] || 0;
                        seconds = dms.value[2] || 0;
                    } else {
                        // Already in decimal format
                        return parseFloat(dms.value) * (ref === 'S' || ref === 'W' ? -1 : 1);
                    }
                } else if (typeof dms === 'number') {
                    // Already in decimal format
                    return dms * (ref === 'S' || ref === 'W' ? -1 : 1);
                } else {
                    console.error('Unrecognized DMS format:', dms);
                    return 0;
                }
                
                // Handle fractional values (rational numbers)
                if (Array.isArray(degrees)) degrees = degrees[0] / degrees[1];
                if (Array.isArray(minutes)) minutes = minutes[0] / minutes[1];
                if (Array.isArray(seconds)) seconds = seconds[0] / seconds[1];
                
                let dd = degrees + minutes/60 + seconds/3600;
                
                // Apply direction
                if (ref === "S" || ref === "W") dd = dd * -1;
                
                console.log('Converted to DD:', dd);
                return dd;
            }

            async createOverlay(img, gpsCoords, filename, shouldScroll = true) {
                const canvas = document.getElementById('previewCanvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size
                canvas.width = img.width;
                canvas.height = img.height;
                
                // Draw original image
                ctx.drawImage(img, 0, 0);
                
                // Get coordinates (custom or GPS)
                let coords = this.getCustomCoordinates() || gpsCoords;
                
                if (!coords) {
                    this.showInfo('No GPS coordinates found in image metadata. Please enter custom coordinates.', 'error');
                    coords = { latitude: 0, longitude: 0, source: 'No GPS data' };
                }
                
                // Get configuration
                const config = this.getConfiguration();
                
                // Format coordinates
                const latStr = this.formatCoordinate(coords.latitude, true, config.decimalPlaces);
                const lonStr = this.formatCoordinate(coords.longitude, false, config.decimalPlaces);
                
                const emoji = config.includeEmoji ? "üìç " : "";
                const coordText = `${emoji}${latStr}, ${lonStr}`;
                const sourceText = `Source: ${coords.source}`;
                
                // Calculate overlay dimensions
                ctx.font = `${config.coordinateFontSize}px Arial, sans-serif`;
                const coordMetrics = ctx.measureText(coordText);
                
                ctx.font = `${config.sourceFontSize}px Arial, sans-serif`;
                const sourceMetrics = ctx.measureText(sourceText);
                
                // Handle extra information if provided
                let extraInfoMetrics = null;
                let extraInfoLines = [];
                let extraInfoHeight = 0;
                
                if (config.extraInfo) {
                    ctx.font = `${config.sourceFontSize}px Arial, sans-serif`;
                    // Split text into lines that fit within the overlay width
                    const maxLineWidth = config.fullWidth ? canvas.width - 40 : Math.max(coordMetrics.width, sourceMetrics.width);
                    extraInfoLines = this.wrapText(ctx, config.extraInfo, maxLineWidth);
                    extraInfoHeight = extraInfoLines.length * (config.sourceFontSize + 5); // 5px line spacing
                    
                    // Calculate widths for all extra info lines
                    const extraInfoWidths = extraInfoLines.map(line => ctx.measureText(line).width);
                    const maxExtraInfoWidth = Math.max(...extraInfoWidths);
                    extraInfoMetrics = { width: maxExtraInfoWidth };
                }
                
                const maxTextWidth = Math.max(
                    coordMetrics.width, 
                    sourceMetrics.width,
                    extraInfoMetrics ? extraInfoMetrics.width : 0
                );
                const overlayWidth = config.fullWidth ? canvas.width : maxTextWidth + (config.verticalPadding / 2);
                const overlayHeight = config.coordinateFontSize + config.sourceFontSize + extraInfoHeight + config.verticalPadding + (extraInfoHeight > 0 ? 20 : 0);
                
                // Calculate overlay position
                let overlayX = 0;
                let overlayY = 0;
                
                if (config.fullWidth) {
                    overlayX = 0;
                } else {
                    switch (config.alignment) {
                        case 'center': overlayX = (canvas.width - overlayWidth) / 2; break;
                        case 'right': overlayX = canvas.width - overlayWidth; break;
                        default: overlayX = 0;
                    }
                }
                
                switch (config.verticalPosition) {
                    case 'top': overlayY = 0; break;
                    case 'center': overlayY = (canvas.height - overlayHeight) / 2; break;
                    default: overlayY = canvas.height - overlayHeight;
                }
                
                // Draw background
                ctx.fillStyle = `rgba(${config.backgroundColor.r}, ${config.backgroundColor.g}, ${config.backgroundColor.b}, ${config.backgroundOpacity})`;
                ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);
                
                // Calculate text positions
                let coordX, sourceX;
                if (config.alignment === 'center' || config.fullWidth) {
                    coordX = overlayX + (overlayWidth - coordMetrics.width) / 2;
                    sourceX = overlayX + (overlayWidth - sourceMetrics.width) / 2;
                } else if (config.alignment === 'right') {
                    coordX = overlayX + overlayWidth - coordMetrics.width - 20;
                    sourceX = overlayX + overlayWidth - sourceMetrics.width - 20;
                } else {
                    coordX = overlayX + 20;
                    sourceX = overlayX + 20;
                }
                
                const coordY = overlayY + config.verticalPadding / 2 + config.coordinateFontSize;
                const sourceY = coordY + config.sourceFontSize + 20;
                
                // Draw coordinate text
                ctx.font = `${config.coordinateFontSize}px Arial, sans-serif`;
                ctx.fillStyle = config.coordinateColor;
                ctx.fillText(coordText, coordX, coordY);
                
                // Draw source text
                ctx.font = `${config.sourceFontSize}px Arial, sans-serif`;
                ctx.fillStyle = config.sourceColor;
                ctx.fillText(sourceText, sourceX, sourceY);
                
                // Draw extra information if provided
                if (config.extraInfo && extraInfoLines.length > 0) {
                    ctx.font = `${config.sourceFontSize}px Arial, sans-serif`;
                    ctx.fillStyle = config.sourceColor;
                    
                    let extraInfoY = sourceY + config.sourceFontSize + 15;
                    extraInfoLines.forEach((line, index) => {
                        let extraInfoX;
                        const lineWidth = ctx.measureText(line).width;
                        
                        if (config.alignment === 'center' || config.fullWidth) {
                            extraInfoX = overlayX + (overlayWidth - lineWidth) / 2;
                        } else if (config.alignment === 'right') {
                            extraInfoX = overlayX + overlayWidth - lineWidth - 20;
                        } else {
                            extraInfoX = overlayX + 20;
                        }
                        
                        ctx.fillText(line, extraInfoX, extraInfoY);
                        extraInfoY += config.sourceFontSize + 5;
                    });
                }
                
                // Show preview
                canvas.style.display = 'block';
                canvas.className = 'image-preview';
                
                // Enable download
                document.getElementById('downloadBtn').disabled = false;
                document.getElementById('downloadBtn').style.display = 'inline-block';
                
                // Store data for download
                this.currentImageData = {
                    canvas: canvas,
                    filename: filename,
                    coordinates: coords
                };
                
                this.showInfo(`‚úÖ Overlay created! Coordinates: ${latStr}, ${lonStr}`, 'success');
                
                // Automatically scroll to the preview section
                if (shouldScroll) {
                    setTimeout(() => {
                        this.scrollToPreview();
                    }, 300); // Small delay to ensure everything is rendered
                }
            }

            scrollToPreview() {
                const previewSection = document.querySelector('.preview-section');
                const canvas = document.getElementById('previewCanvas');
                
                // Only scroll if user has processed an image and canvas is visible
                if (this.hasProcessedImage && previewSection && canvas.style.display === 'block') {
                    // Calculate the scroll position to center the image in the viewport
                    const rect = canvas.getBoundingClientRect();
                    const windowHeight = window.innerHeight;
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    
                    // Calculate target scroll position (center the image in viewport)
                    const targetY = scrollTop + rect.top - (windowHeight / 2) + (rect.height / 2);
                    
                    // Smooth scroll to the target position
                    window.scrollTo({
                        top: Math.max(0, targetY), // Ensure we don't scroll above the page
                        behavior: 'smooth'
                    });
                }
            }

            getCustomCoordinates() {
                const lat = parseFloat(document.getElementById('customLat').value);
                const lon = parseFloat(document.getElementById('customLon').value);
                
                if (!isNaN(lat) && !isNaN(lon)) {
                    return { latitude: lat, longitude: lon, source: 'Custom' };
                }
                return null;
            }

            getConfiguration() {
                const bgColor = this.hexToRgb(document.getElementById('backgroundColor').value);
                
                return {
                    coordinateFontSize: parseInt(document.getElementById('coordinateFontSize').value),
                    sourceFontSize: parseInt(document.getElementById('sourceFontSize').value),
                    coordinateColor: document.getElementById('coordinateColor').value,
                    sourceColor: document.getElementById('sourceColor').value,
                    backgroundColor: bgColor,
                    backgroundOpacity: 0.7,
                    verticalPosition: document.getElementById('verticalPosition').value,
                    alignment: document.getElementById('alignment').value,
                    fullWidth: document.getElementById('fullWidth').checked,
                    decimalPlaces: parseInt(document.getElementById('decimalPlaces').value),
                    includeEmoji: document.getElementById('includeEmoji').checked,
                    verticalPadding: parseInt(document.getElementById('verticalPadding').value),
                    extraInfo: document.getElementById('extraInfo').value.trim()
                };
            }

            formatCoordinate(coord, isLatitude, decimalPlaces) {
                const abs = Math.abs(coord);
                const direction = isLatitude ? (coord >= 0 ? 'N' : 'S') : (coord >= 0 ? 'E' : 'W');
                return `${abs.toFixed(decimalPlaces)}¬∞${direction}`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }

            updatePreview() {
                if (this.currentImageData && this.processedImageFile && this.originalGPSCoords) {
                    // Use the stored processed image file and GPS coordinates (don't scroll since user is just updating config)
                    const img = new Image();
                    const url = URL.createObjectURL(this.processedImageFile);
                    
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        // Use stored GPS coordinates
                        this.createOverlay(img, this.originalGPSCoords, this.processedImageFile.name, false); // false = don't scroll
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        console.error('Failed to load processed image file');
                        this.showInfo('‚ùå Failed to update preview. Please try uploading the image again.', 'error');
                    };
                    
                    img.src = url;
                }
            }

            getCurrentLocation() {
                const locationBtn = document.getElementById('getLocationBtn');
                const locationStatus = document.getElementById('locationStatus');
                const locationDisplay = document.getElementById('locationDisplay');
                
                if (!navigator.geolocation) {
                    locationStatus.textContent = '‚ùå Geolocation is not supported by this browser';
                    locationStatus.className = 'location-status error';
                    return;
                }

                locationBtn.disabled = true;
                locationBtn.textContent = 'üìç Getting Location...';
                locationStatus.textContent = 'üîÑ Requesting location permission...';
                locationStatus.className = 'location-status info';

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        const accuracy = position.coords.accuracy;
                        
                        // Store the location data
                        this.currentBrowserLocation = {
                            latitude: lat,
                            longitude: lon,
                            accuracy: accuracy
                        };

                        // Update the display
                        document.getElementById('browserLat').textContent = `Latitude: ${lat.toFixed(9)}`;
                        document.getElementById('browserLon').textContent = `Longitude: ${lon.toFixed(9)}`;
                        
                        locationStatus.textContent = `‚úÖ Location found! Accuracy: ¬±${Math.round(accuracy)}m`;
                        locationStatus.className = 'location-status success';
                        locationDisplay.style.display = 'block';
                        
                        locationBtn.disabled = false;
                        locationBtn.textContent = 'üìç Get My Current Location';
                    },
                    (error) => {
                        let errorMessage = '‚ùå ';
                        console.log('Geolocation error:', error);
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Location access denied by user';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information unavailable';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out';
                                break;
                            default:
                                errorMessage += 'Unknown location error';
                                break;
                        }
                        
                        locationStatus.textContent = errorMessage;
                        locationStatus.className = 'location-status error';
                        locationDisplay.style.display = 'none';
                        
                        locationBtn.disabled = false;
                        locationBtn.textContent = 'üìç Get My Current Location';
                    },
                    options
                );
            }

            useBrowserLocation() {
                if (!this.currentBrowserLocation) {
                    this.showInfo('‚ùå No browser location available. Please get your location first.', 'error');
                    return;
                }

                // Set the custom coordinates to the browser location
                document.getElementById('customLat').value = this.currentBrowserLocation.latitude;
                document.getElementById('customLon').value = this.currentBrowserLocation.longitude;
                
                // Update the preview if an image is loaded
                if (this.currentImageData) {
                    this.updatePreview();
                }
                
                this.showInfo('‚úÖ Browser location set as custom coordinates!', 'success');
            }

            downloadImage() {
                if (!this.currentImageData) return;
                
                const canvas = this.currentImageData.canvas;
                const filename = this.currentImageData.filename;
                
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.getOutputFilename(filename);
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }

            getOutputFilename(originalName) {
                const lastDot = originalName.lastIndexOf('.');
                if (lastDot === -1) {
                    return originalName + '_with_coordinates.jpg';
                }
                const name = originalName.substring(0, lastDot);
                const ext = originalName.substring(lastDot);
                return `${name}_with_coordinates${ext}`;
            }

            async processAllImages() {
                if (this.selectedFiles.length <= 1) return;
                
                this.showInfo(`Processing ${this.selectedFiles.length} images...`, 'info');
                
                for (let i = 0; i < this.selectedFiles.length; i++) {
                    try {
                        await this.processImage(this.selectedFiles[i]);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
                        this.downloadImage();
                    } catch (error) {
                        console.error(`Error processing ${this.selectedFiles[i].name}:`, error);
                    }
                }
                
                this.showInfo(`‚úÖ Processed all ${this.selectedFiles.length} images!`, 'success');
            }

            showInfo(message, type = 'info') {
                const panel = document.getElementById('infoPanel');
                panel.className = `${type}-panel`;
                panel.textContent = message;
                panel.style.display = 'block';
            }

            showProgress(percent) {
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                progressBar.style.display = 'block';
                progressFill.style.width = percent + '%';
            }

            hideProgress() {
                const progressBar = document.getElementById('progressBar');
                progressBar.style.display = 'none';
            }

            wrapText(ctx, text, maxWidth) {
                // First split by manual line breaks (preserving user's intentional line breaks)
                const manualLines = text.split(/\r?\n/);
                const wrappedLines = [];
                
                manualLines.forEach(line => {
                    if (line.trim() === '') {
                        // Preserve empty lines
                        wrappedLines.push('');
                        return;
                    }
                    
                    // Check if the line fits within maxWidth
                    if (ctx.measureText(line).width <= maxWidth) {
                        wrappedLines.push(line);
                    } else {
                        // Line is too long, wrap it by words
                        const words = line.split(' ');
                        let currentLine = words[0] || '';

                        for (let i = 1; i < words.length; i++) {
                            const word = words[i];
                            const testLine = currentLine + " " + word;
                            const width = ctx.measureText(testLine).width;
                            
                            if (width <= maxWidth) {
                                currentLine = testLine;
                            } else {
                                wrappedLines.push(currentLine);
                                currentLine = word;
                            }
                        }
                        if (currentLine) {
                            wrappedLines.push(currentLine);
                        }
                    }
                });
                
                return wrappedLines;
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new ImageCoordinateOverlay();
        });
    </script>
</body>
</html> 